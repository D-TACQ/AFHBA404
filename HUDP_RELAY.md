# HUDP_RELAY

## HUDP_RELAY

- Is a standard MGT/PCIe LLC system with HUDP add on
- A UUT with regular XI, XO payload:
  - sends LLC data to HOST using MGT/PCIe using a single Vector VI
    - VI is a single DMA transaction with an integer number of whole PCIe TLP's length 64byte.
    - VI uses the SPAD feature to both add instrumentation and to pad the vector length to a whole number of TLP's  
  - pulls LLC data from HOST using MGT/PCIe using a single Vector VO
    - VO is a single DMA transition with an integer number of whole PCIe TLP's length 64b.
    - VO uses the PAD (aka "TCAN") feature to pad the vector length to a whole number of TLP's. The maximum length of PAD is 16xu32.
- With HUDP_RELAY, VO is deliberately extended using PAD to include additional "Relay" data.
- The HUDP Hardware UDP processing unit is set to relay a slice of VO to remote client[s]

- In "Normal" LLC, all processes are driven by the sample clock
  - On the clock, the ADC array samples simultaneously, the AGGREGATOR gathers  data to VI and sends VI to the host
  - On the clock, the UUT "pulls" VO from the HOST, and the DISTRIBUTOR scatters data to the outputs.
  
- In a PULL_HOST_TRIGGER system, a software action on the HOSTP triggers the VO fetch.
  - in our toy example, we hit the pull_host_trigger every second sample so that there's a clear distinction between regular clocked output and host trigger.
  - the example data pattern is generated by this host-side code:
  https://github.com/D-TACQ/AFHBA404/blob/a96bac3875afa0f82b2cb93d792f13a2885635ae/ACQPROC/HudpRelaySystemInterface.cpp#L88-L95
  
- In the text below, HOST and PCSHOST refer to the PCIe computer with AFHBA404, and RXHOST is the remote UDP receiver.


## Installation

### System

- we assume that your HOST computer has kernel-devel, g++, python3 installed
 - in our examples, the HOST is "brotto":
 
 ```
 [dt100@brotto AFHBA404]$ cat /etc/redhat-release 
CentOS Linux release 7.4.1708 (Core) 
[dt100@brotto AFHBA404]$ head -n1 /proc/meminfo 
MemTotal:       16216156 kB
[dt100@brotto AFHBA404]$ grep "model name" /proc/cpuinfo 
model name	: Intel(R) Xeon(R) CPU E3-1220 v5 @ 3.00GHz
model name	: Intel(R) Xeon(R) CPU E3-1220 v5 @ 3.00GHz
model name	: Intel(R) Xeon(R) CPU E3-1220 v5 @ 3.00GHz
model name	: Intel(R) Xeon(R) CPU E3-1220 v5 @ 3.00GHz
 ```
 
### Fetch D-TACQ Sofware
 
- we assume a user with sudo privileges. In our examples, nominally this user is "dt100"

```
cd ~; mkdir PROJECTS; cd PROJECTS;
git clone https://www.d-tacq.com/D-TACQ/acq400_hapi
git clone https://www.d-tacq.com/D-TACQ/AFHBA404
```

- in our testing, we have a private (Ethernet 1000LX network to another computer "naboo" as the data receiver RXHOSTE
  - naboo: 10.12.198.254 
  - UUT:  10.12.198.100    on HUDP port on MGTD

- Strongly Recommended: Use cs-studio to monitor status https://github.com/D-TACQ/ACQ400CSS/blob/master/README.md#acq400css
  - Clocktree OPI: shows Clock Status, including clock frequencies
  - Capture OPI: shows Capture Status, including data flow rates.
  - HUDP OPI : shows HUDP status, including live data rates.
  - MGT OPI : shows MGT (PCIe DMA status, including live data rates)


### Build AFHBA404 support

Follow instructions in INSTALL

#### One Time

```
cd AFHBA404
make
sudo ./scripts/install-hotplug
```

#### Every Boot

```
sudo ./scripts/loadNIRQ
sudo ./scripts/get-ident-all

pushd ../acq400_hapi; source ./setpath; popd
```

### ACQPROC Configuration

- ACQPROC is a framework for running LLC, it features data-driven configuration.
- The easiest way to get a system-specific config file is to auto-create it, eg

```
dt100@brotto AFHBA404]$  ./HAPI/lsafhba.py --save_config ACQPROC/configs/mast_raw.json
0 HostComms(host='brotto', dev='0', uut='acq2106_354', cx='A')
```

- the raw config file ACQPROC/configs/mast_raw.json looks like this:

```json
{
    "AFHBA": {
        "UUT": [
            {
                "DEVNUM": 0,
                "name": "acq2106_354",
                "type": "pcs",
                "sync_role": "master",
                "COMMS": "A",
                "VI": {
                    "AI16": 32,
                    "DI32": 3,
                    "SP32": 13,
                    "AISITES": [
                        1
                    ],
                    "DIOSITES": [
                        4,
                        5,
                        6
                    ],
                    "NXI": 4
                },
                "VO": {
                    "AO16": 64,
                    "DO32": 3,
                    "AOSITES": [
                        2,
                        3
                    ],
                    "DIOSITES": [
                        4,
                        5,
                        6
                    ],
                    "NXO": 5
                }
            }
        ]
    }
}

```

- We then copy and modify the file to add the site specific features:
  - DO32 are ALL OUTPUTS
  - We specify a HUDP_RELAY section "HP32" of 12 * u32 (ie 6xAO420, 4x16 bit)
    - NB: the PAD section cannot current exceed 64b, and already includes 3 * u32 from 3 * DIO
  
```
diff -urN ACQPROC/configs/mast_raw.json ACQPROC/configs/mast_HP32_12.json
--- ACQPROC/configs/mast_raw.json	2022-11-29 06:58:47.778833411 +0000
+++ ACQPROC/configs/mast_HP32_12.json	2022-11-29 06:58:38.831921558 +0000
@@ -24,6 +24,8 @@
                 "VO": {
                     "AO16": 64,
                     "DO32": 3,
+		    "DO_BYTE_IS_OUTPUT" : [ "1,1,1,1", "1,1,1,1", "1,1,1,1" ],
+		    "HP32": 12,
                     "AOSITES": [
                         2,
                         3

```

- creating a new config file ACQPROC/configs/mast_HP32_12.json

```json
{
    "AFHBA": {
        "UUT": [
            {
                "DEVNUM": 0,
                "name": "acq2106_354",
                "type": "pcs",
                "sync_role": "master",
                "COMMS": "A",
                "VI": {
                    "AI16": 32,
                    "DI32": 3,
                    "SP32": 13,
                    "AISITES": [
                        1
                    ],
                    "DIOSITES": [
                        4,
                        5,
                        6
                    ],
                    "NXI": 4
                },
                "VO": {
                    "AO16": 64,
                    "DO32": 3,
		    "DO_BYTE_IS_OUTPUT" : [ "1,1,1,1", "1,1,1,1", "1,1,1,1" ],
		    "HP32": 12,
                    "AOSITES": [
                        2,
                        3
                    ],
                    "DIOSITES": [
                        4,
                        5,
                        6
                    ],
                    "NXO": 5
                }
            }
        ]
    }
}

```

## Running the system

- First Time Action:
  - acqproc dummy run

```bash
./ACQPROC/acqproc ACQPROC/configs/mast_HP32_12.json 

# create runtime.json: a view of ACQPROC's internal model of the system. 
# We want to know the offset of the HP32 slice in the vector:
[dt100@brotto AFHBA404]$ grep -A 4 VO_OFFSETS runtime.json 
                    "VO_OFFSETS": {
                        "AO16": 0,
                        "DO32": 128,
                        "HP32": 140
                    },
```

 - the HP32 slice is at byte offset 140 in the VO vector. We want the UDP slice off the data to start there, so use this as the argument for hudp_relay below ..
 - we set CLK to 10k to keep the speed down..

```bash
cd ~/PROJECTS/AFHBA404; pushd ../acq400_hapi; source ./setpath; popd
SITECLIENT_TRACE=1 CLK=10000 ./scripts/acqproc_multi.sh ACQPROC/configs/mast_HP32_12.json configure_uut
SITECLIENT_TRACE=1 ../acq400_hapi/user_apps/acq2106/hudp_setup.py \
--rx_ip=10.12.198.254 --tx_ip 10.12.198.100 --run0='notouch' --play0='notouch' --hudp_relay=140 acq2106_354 none
```

- Per Shot action, run the shot:
  - on UDP Rx (naboo)
  
```bash
nc -ul 10.12.198.254 53676 | pv > hudp.raw
```
  
  - on HOST
  
```bash
NOCONFIGURE=1 SITECLIENT_TRACE=1 THE_ACQPROC=./ACQPROC/acqproc_hpr CLK=10000 POST=10000 \
SINGLE_THREAD_CONTROL=host_pull_trigger=0,0 ./scripts/acqproc_multi.sh ACQPROC/configs/mast_HP32_12.json
```
- During the shot, on Rx Host
  - NB: Packets will be sent steadily on clock _before_ the trigger. This is a reflection of how the LLC system output works.
  - It's the PCS's responsibility to load the VO vector source in host memory with sensible values BEFORE starting the process.
  - The continuous update is used to implement things like DIO_WATCHDOG.

```
[dt100@naboo ~]$ nc -ul 10.12.198.254 53676 | pv > hudp.raw
29.8MiB 0:11:04 [ 508kiB/s] [                                                     <=>
```

- Analysis at remote UDP Rx

```bash
[dt100@naboo ~]$ hexdump -e '13/4 "%08x," "\n"' hudp.raw  | more
00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,
*
00000001,0000005e,22222222,33333333,0003e5d8,0004e5d8,0005e5d8,0006e5d8,0007e5d8,0008e5d8,0009e5d8,000ae5d8,00000000,
00000002,000000c2,22222222,33333333,0003e6c1,0004e6c1,0005e6c1,0006e6c1,0007e6c1,0008e6c1,0009e6c1,000ae6c1,00000000,
00000003,00000126,22222222,33333333,0003e7ae,0004e7ae,0005e7ae,0006e7ae,0007e7ae,0008e7ae,0009e7ae,000ae7ae,00000000,
00000004,0000018a,22222222,33333333,0003e89c,0004e89c,0005e89c,0006e89c,0007e89c,0008e89c,0009e89c,000ae89c,00000000,
00000005,000001ee,22222222,33333333,0003e98a,0004e98a,0005e98a,0006e98a,0007e98a,0008e98a,0009e98a,000ae98a,00000000,
00000006,00000252,22222222,33333333,0003ea7e,0004ea7e,0005ea7e,0006ea7e,0007ea7e,0008ea7e,0009ea7e,000aea7e,00000000,
00000007,000002b6,22222222,33333333,0003eb6e,0004eb6e,0005eb6e,0006eb6e,0007eb6e,0008eb6e,0009eb6e,000aeb6e,00000000,
```


- Host Pull Trigger Action

  - run the UDP Rx again:
 
```
[dt100@naboo ~]$ nc -ul 10.12.198.254 53676 | pv > hudp.raw
0MiB 0:11:04 [ 0kiB/s] [                                                 <=>
```

```bash
NOCONFIGURE=1 SITECLIENT_TRACE=1 THE_ACQPROC=./ACQPROC/acqproc_hpr CLK=10000 POST=10000 \
SINGLE_THREAD_CONTROL=host_pull_trigger=1,0 ./scripts/acqproc_multi.sh ACQPROC/configs/mast_HP32_12.json
```

  - The Control Program chooses to trigger on alternate incoming samples, as shown below in UDP Rx analysis (SPAD[0] in column 0)
  - Note two differences on the UDP Rx
    - A single packet is sent initially, with no more packets until the system is triggered.
    - The data rate is lower.
  
```
[dt100@naboo ~]$ hexdump -e '13/4 "%08x," "\n"' hudp.raw  | more
00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,
*
00000002,00000075,22222222,33333333,000424c9,000524c9,000624c9,000724c9,000824c9,000924c9,000a24c9,000b24c9,00000000,
00000004,0000013d,22222222,33333333,00042320,00052320,00062320,00072320,00082320,00092320,000a2320,000b2320,00000000,
00000006,00000205,22222222,33333333,0004216d,0005216d,0006216d,0007216d,0008216d,0009216d,000a216d,000b216d,00000000,
00000008,000002cd,22222222,33333333,00041fb7,00051fb7,00061fb7,00071fb7,00081fb7,00091fb7,000a1fb7,000b1fb7,00000000,
0000000a,00000395,22222222,33333333,00041df3,00051df3,00061df3,00071df3,00081df3,00091df3,000a1df3,000b1df3,00000000,

```
  - for broadcast, include --broadcast=1 in the hudp_setup
  
```bash
../acq400_hapi/user_apps/acq2106/hudp_setup.py --rx_ip=10.12.198.254 --tx_ip 10.12.198.100 \
	--run0='notouch' --play0='notouch' --hudp_relay=140 --broadcast=1 acq2106_354 none
```
    - on UDP Rx..
```
[dt100@naboo ~]$ nc -ul 10.12.198.255 53676 | pv > hudp.raw
```

- comment on PAD size. 
  - As stated above. The maximum PAD size is 64b - space needed for DO. 
    - in the example system, that makes 12xu32, or enough for 6 AO420FMC, Quad 16 bit DAC.
    - in our contrived example, we used up the first 4 columns with a "SPAD RELAY", this was helpful for instrumentation.
    - We'd actually recommend to keep the SPAD info in the UDP packet, it is helpful.
    - @@WORKTODO: do we need a bigger PAD/TCAN. 64b was logical for padding to next 64b TLP, but with this new function it's clear a longer PAD would be useful. However, it's also difficult to implement.
    - @@WORKTDO: to clear host_pull_trigger before reverting to regular clocked mode, run this from the command line:
  
```bash
[root@brotto dt100]# echo 0 > /dev/rtm-t.0.ctrl/select_pull_host_trigger
```
  
- Queries? Please contact peter.milne@d-tacq.com

- APPENDIX: sample output log, during the shot, on PCSHOST. A successful shot is followed by an analysis of the short data acquired via PCIe.

```
[dt100@brotto AFHBA404]$ NOCONFIGURE=1 SITECLIENT_TRACE=1 THE_ACQPROC=./ACQPROC/acqproc_hpr CLK=10000 POST=10000 SINGLE_THREAD_CONTROL=host_pull_trigger=0,0 ./scripts/acqproc_multi.sh ACQPROC/configs/mast_HP32_12.json
UUT1 acq2106_354
UUT2
UUTS acq2106_354
DEVMAX 2
python3 /home/dt100/PROJECTS/acq400_hapi/user_apps/acq400/acq400_streamtonowhere.py --samples=10000 acq2106_354
nsamples set 10000
HBA0 VI:128 VO:188 devs=0
	[0] dev:0 acq2106_354 VI:128 VO:188 Offset of SPAD IN VI :76
 System Interface Indices 0,0
HudpRelaySystemInterface.cpp::static SystemInterface& SystemInterface::factory(const HBA&)
Siteclient(acq2106_354, 4220) >SITELIST
Siteclient(acq2106_354, 4220) <216,1=423,2=ao,3=ao,4=dio,5=dio,6=dio
Siteclient(acq2106_354, 4222) >module_name
Siteclient(acq2106_354, 4223) >module_name
Siteclient(acq2106_354, 4221) >module_name
Siteclient(acq2106_354, 4224) >module_name
Siteclient(acq2106_354, 4225) >module_name
Siteclient(acq2106_354, 4222) <ao424elf
Siteclient(acq2106_354, 4223) <ao424elf
Siteclient(acq2106_354, 4221) <acq423elf
Siteclient(acq2106_354, 4224) <dio432
Siteclient(acq2106_354, 4225) <dio432
Siteclient(acq2106_354, 4220) >state
Siteclient(acq2106_354, 4220) <0 0 0 0 0
Siteclient(acq2106_354, 4220) >streamtonowhered=stop
Siteclient(acq2106_354, 4220) <
Siteclient(acq2106_354, 4221) >SIG:sample_count:RESET=1
Siteclient(acq2106_354, 4221) <
Siteclient(acq2106_354, 4221) >SIG:sample_count:RESET=0
Siteclient(acq2106_354, 4221) <
Siteclient(acq2106_354, 4220) >CONTINUOUS:STATE
Siteclient(acq2106_354, 4220) <CONTINUOUS:STATE IDLE
Arming systems now - please wait. Do not trigger yet.
Siteclient(acq2106_354, 4220) >streamtonowhered=start
Siteclient(acq2106_354, 4220) <
Siteclient(acq2106_354, 4220) >CONTINUOUS:STATE
Siteclient(acq2106_354, 4220) <CONTINUOUS:STATE IDLE
Siteclient(acq2106_354, 4220) >CONTINUOUS:STATE
Siteclient(acq2106_354, 4220) <CONTINUOUS:STATE IDLE
Siteclient(acq2106_354, 4220) >CONTINUOUS:STATE
Siteclient(acq2106_354, 4220) <CONTINUOUS:STATE IDLE
Siteclient(acq2106_354, 4220) >CONTINUOUS:STATE
Siteclient(acq2106_354, 4220) <CONTINUOUS:STATE IDLE
Siteclient(acq2106_354, 4220) >CONTINUOUS:STATE
Siteclient(acq2106_354, 4220) <CONTINUOUS:STATE IDLE
Siteclient(acq2106_354, 4220) >CONTINUOUS:STATE
Siteclient(acq2106_354, 4220) <CONTINUOUS:STATE IDLE
Siteclient(acq2106_354, 4220) >CONTINUOUS:STATE
Siteclient(acq2106_354, 4220) <CONTINUOUS:STATE IDLE
Siteclient(acq2106_354, 4220) >CONTINUOUS:STATE
Siteclient(acq2106_354, 4220) <CONTINUOUS:STATE IDLE
Siteclient(acq2106_354, 4220) >CONTINUOUS:STATE
Siteclient(acq2106_354, 4220) <CONTINUOUS:STATE ARM
Siteclient(acq2106_354, 4220) >SIG:SRC:TRG:0=EXT
Siteclient(acq2106_354, 4220) <
Siteclient(acq2106_354, 4220) >SIG:SRC:TRG:1=STRIG
stored acq2106_354_VI.dat, len=1279872
stored acq2106_354_VO.dat, len=1879812
Control Program Finished
Siteclient(acq2106_354, 4220) <
All UUTs are armed and ready for trigger.
Siteclient(acq2106_354, 4220) >CONTINUOUS:STATE
Siteclient(acq2106_354, 4220) <CONTINUOUS:STATE RUN
Streamed 0 of 10000 samples
Siteclient(acq2106_354, 4221) >sample_count
Siteclient(acq2106_354, 4221) <16865
Streamed 16865 of 10000 samples
Siteclient(acq2106_354, 4221) >sample_count
Siteclient(acq2106_354, 4221) <26870

Stream finished.
Siteclient(acq2106_354, 4220) >streamtonowhered=stop
Siteclient(acq2106_354, 4220) <
python3 /home/dt100/PROJECTS/acq400_hapi/user_apps/acq400/acq400_streamtonowhere.py done 0

Running analysis now.
--------------------
python3 scripts/acqproc_analysis.py --ones=1 --json=1 --json_src=./runtime.json --src=/home/dt100/PROJECTS/AFHBA404/
TKAgg not available for matplot
Running analysis for UUT: acq2106_354
show SPAD: hexdump -ve '32/2 "%04x," 3/4 "%08x," 13/4 "%08x," "\n"' acq2106_354_VI.dat  | cut -d, -f36-43 | head -n 4
00000001,0000003d,22222222,33333333,dead0005,dead0005,0369e282,a7777354
00000002,000000a1,22222222,33333333,dead0005,dead0005,0369e282,a7777354
00000003,00000105,22222222,33333333,dead0005,dead0005,0369e283,a7777354
00000004,00000169,22222222,33333333,dead0005,dead0005,0369e283,a7777354
show whole VI like this:
hexdump -ve '32/2 "%04x," 3/4 "%08x," 13/4 "%08x," "\n"' acq2106_354_VI.dat 
Finished collecting data
T_LATCH differences:  1 , happened:  51  times
T_LATCH differences:  2 , happened:  9  times
T_LATCH differences:  3 , happened:  0  times
(639936,)
data end: 37
spad_len:  13
64
len diffs = 1007
max data = [855.075 855.075 855.075 ... 855.075 855.075 855.075]
latency plot saved as acq2106_354_latency.png

..
```

- Appendix: runtime.json, view of ACQPROC's model of the system

  - AFHBA: the original config file
  - SYS : the ACQPROC Model, comprising
    - please see machine inserted comments at the end.

```json
{
    "AFHBA": {
        "DEVNUM": null,
        "UUT": [
            {
                "COMMS": "A",
                "DEVNUM": 0,
                "VI": {
                    "AI16": 32,
                    "AISITES": [
                        1
                    ],
                    "DI32": 3,
                    "DIOSITES": [
                        4,
                        5,
                        6
                    ],
                    "NXI": 4,
                    "SP32": 13
                },
                "VO": {
                    "AO16": 64,
                    "AOSITES": [
                        2,
                        3
                    ],
                    "DIOSITES": [
                        4,
                        5,
                        6
                    ],
                    "DO32": 3,
                    "DO_BYTE_IS_OUTPUT": [
                        "1,1,1,1",
                        "1,1,1,1",
                        "1,1,1,1"
                    ],
                    "HP32": 12,
                    "NXO": 5
                },
                "name": "acq2106_354",
                "sync_role": "master",
                "type": "pcs"
            }
        ]
    },
    "SYS": {
        "GLOBAL_LEN": {
            "VI": {
                "AI16": 32,
                "AI32": 0,
                "DI32": 3,
                "SP32": 13
            },
            "VO": {
                "AO16": 64,
                "CC32": 0,
                "DO32": 3,
                "HP32": 12,
                "PW32": 0
            }
        },
        "SPIX": {
            "POLLCOUNT": 2,
            "TLATCH": 0,
            "USECS": 1
        },
        "UUT": {
            "GLOBAL_INDICES": [
                {
                    "VI": {
                        "AI16": 0,
                        "DI32": 0,
                        "SP32": 0
                    },
                    "VO": {
                        "AO16": 0,
                        "DO32": 0,
                        "HP32": 0
                    }
                }
           ],
            "LOCAL": [
                {
                    "VI_OFFSETS": {
                        "AI16": 0,
                        "DI32": 64,
                        "SP32": 76
                    },
                    "VO_OFFSETS": {
                        "AO16": 0,
                        "DO32": 128,
                        "HP32": 140
                    },
                    "VX_LEN": {
                        "VI": 128,
                        "VO": 188
                    }
                }
            ]
        },
        "__comment1__": "created from ACQPROC/configs/mast_HP32_12.json",
        "__comment2__": "LOCAL VI_OFFSETS: field offset VI in bytes",
        "__comment3__": "LOCAL VO_OFFSETS: field offset VO in bytes",
        "__comment4__": "LOCAL VX_LEN: length of VI|VO in bytes",
        "__comment5__": "GLOBAL_LEN: total length of each type in SystemInterface",
        "__comment6__": "GLOBAL_INDICES: index of field in type-specific array in SI",
        "__comment7__": "SPIX: Scratch Pad Index, index of field in SP32"
    }
}

```
 
